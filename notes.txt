
Notes:

TODO It would be better if you didn't have to remember how the namespace works

TODO make the page load after it scrolls

TODO home_view.php must automatically get the row count, auto increment, and insert the new pet row number in the ID

TODO div blocks to pre divide up the screen as a convenience

TODO delete commented code, push to github

TODO trivial create, update, delete examples

TODO div blocks to pre divide up the screen as a convenience, the api would be such that you could pick which area of the screen to insert/update elements

TODO pets_controller must automatically get the row count, auto increment, and insert the new pet row number in the ID

TODO BLOCK loops in template system

TODO rest verbs (POST, GET, PUT, DELETE) automatically perform action in root controller class


url request for object class (noun), "pets"
that object class must be a table in the database
that object class plus id number (separated by underscore) make up the id of the DIV element
not having to remember this would make the framework easier to work with
the DIV element IDs are passed around and parsed automatically
so all you have to remember is that a DIV element ID is just "table_name" + "_" + "record_id"
this framework is set up so that the models are inherited, the Controller and Model are singleton
but the views are broken into separate files and "included"


here is where we lay out the initial view of elments
for each pet create a div with create_div_id()
then call the javascript append_div() to create it
unless the model returns that there are no more
then stop

pull a pets row html from the template
I don't have the template system yet,
so I'm just typing it out



pets element view:

put whatever html goes here for this view subclass

generate html from template

ultimately the element id could be some more optimized hash

use the element id ("pets_3" for example)
request the 3rd pets object from the model
and shove it into some html
unless the model returns null
then return an empty string

unless i change the controller to intercept and pre-process this request
this view will receive a GET request for 
?divid=pets_1

pets_model.php:
$this->model = new Model();
$pet = $this->model->read($id, 'pets');
$this->connect();
$this->name = $pet["name"];
echo $id;

model.php:
include __DIR__.'/pets_model.php';
connect to a database
connect to a cache
store some data here
open json file
convert into array
$string = file_get_contents(__DIR__."/../../data/pets.json");
$modelData = json_decode($string,true);
$this->orm = new ORM();
$query = $this->orm->read($id, 'pets');
$pet = new Pet($query[0]);

controller.php:
create new table or record in database

read record from database

if there is an element being requested
then show the view that displays that element
leaving off the open and close html and body tags

are the controller, model and views too tightly coupled?
would it be nice to be able to add new functionality without changing the controller.php file
or the model.php file either

$parameter_array = explode("_", $_GET['divid']);
$model_name = $parameter_array[0];
$id = $parameter_array[1];
if there is no element id being requested
then show the view that displays the main page

parse get/post parameters

pick the appropiate view and model subclasses from the request

update the model

pets_model.php

public function get_pet_name($category, $counter, $datum) {
	$string = file_get_contents(__DIR__."/../../data/pets.json");
	$modelData = json_decode($string,true);
	$pet_name_data = $modelData[$category][$counter][$datum];
	
	convert the value into an object
	$pet_name_object = new Pet($counter);
	return $pet_name_object;
}

orm.php:

$db = new SQLite3('mysqlitedb.db');

$results = $db->query('SELECT bar FROM foo');
while ($row = $results->fetchArray()) {
    var_dump($row);
}

mvc.js
what if you want to mutate the data?
what functions will do CRUD?


function loadXMLDoc() {
	var xmlhttp;
	
	xmlhttp = new XMLHttpRequest();
	xmlhttp.onreadystatechange = function() {
		if(xmlhttp.readyState == 4 && xmlhttp.status == 200) {
			document.getElementById("div").innerHTML = xmlhttp.responseText;
		}
	}
	xmlhttp.open("GET", "ajax_info.txt", true);
	xmlhttp.send();
}
function create_div_id() {
	// create a "restful" element id by combining element names and numbers
	// so if you had an element with the id "pets" you could call create_div_id("pets", "5")
	// and get back the 5th innerHTML element in the "pets" element
}

